
\chapter{Proposal and Implementation}
\justifying

The goal is to determine how to count nodes around a specific position, or in a specific area, or presenting a 
specific condition. This type of algorithms have interested the research community for a long time since they 
can be used in many applications. Up to now, most of the work done is based on pictures, videos, inductive loops, 
lasers, or other type of sensors. However, just a few works have been developed based on wireless communications 
such as WAVE. For the ITS, some applications include:
\begin{itemize}
\itemsep0em
 \item Adaptive traffic light control systems
\item Free parking lot guidance
\item Detection of traffic congestion
\item Determining the number of vehicles in a portion of a highway
\end{itemize}

%\section{Motivation}
\section{Objective of the Dissertation}
\begin{itemize}
\itemsep0em
\justifying
 \item Develop an algorithm that allows the counting of nodes around a specific position, or in a specific area, or presenting a specific condition, using wireless technology.
 \item Implement the algorithm using simulation tools. 
 \item Study the impact of the speed of the nodes over the algorithm so it can be used in vehicular environments.
 \item Evaluation of the performance of the proposed algorithm for different loads of the network.
\end{itemize}

\section{Research Methodology}
VANET is an exciting new technology with lots of potential and this excitement
sparked an extensive literature study to better understand the technology with all of its
principles and characteristics that distinguishes it from other vehicular technologies.
Thereafter a thorough study was made into the IEEE 802.11p and IEEE 1609.X
standards to acquire the necessary know-how to be able to investigate and complement existing simulation models following this standard.
The study continued into the area of vehicular networks with emphasis on the
limitations such networks currently experience.

When implementing a network simulation model, a key component is the network
simulation environment and corresponding framework. A comprehensive study was made
into different simulators after which the most suitable simulator and
corresponding framework was chosen and closely examined to make proper use of its
features.

The practical simulation work was mainly supported by and built upon the INET
framework for the OMNeT++ network simulator.


\section{Possible Contribution of the Dissertation}
\subsection{Proposal to Count Nodes Around a Specific Position}
The basic idea is :
\begin{itemize}
\itemsep0em
\justifying
 \item Propagate a broadcast message (called COUNT$\textunderscore$REQUEST) from the originator to nodes that are far away from
 the originator with the number of ``hops away'' the receiver of the message is from the originator of the COUNT$\textunderscore$REQUEST.
 \item Propagate unicast messages (COUNT$\textunderscore$REPLY) from the nodes that are far away from the originator towards the
 originator with the total number of nodes counted up to now (called ``Total'' in this algorithm).
\end{itemize}


\begin{figure}[h!]
 \centering
 %\includegraphics[width=14cm,height=5cm]{fig2.png}
 \includegraphics[height=1.4in]{fig2.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Timing Diagram}
\label{fig0}
\end{figure}
\vspace{1cm}
\begin{flushleft}
t2 = t1 + REBROADCAST$\textunderscore$TIME\\
t3 = t1 + REBROADCAST$\textunderscore$TIME + 1*INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST\\
t4 = t1 + REBROADCAST$\textunderscore$TIME + 2*INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST\\
t5 = t1 + REQUEST$\textunderscore$TIMEOUT
\end{flushleft}
%\pagebreak
\justifying
Nodes will rebroadcast COUNT$\textunderscore$REQUEST messages and also sends a COUNT$\textunderscore$REPLY message after
a specific time such as:
\begin{itemize}
\itemsep0em
 \justifying
\item \emph{REBROADCAST$\textunderscore$TIME}: Time between the reception of the first COUNT$\textunderscore$REQUEST, and the first rebroadcast of the 
COUNT$\textunderscore$REQUEST by the node.

\item \emph{INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST}: Time interval between each COUNT$\textunderscore$REQUEST message. In other words, it also represents the
time between two consecutive COUNT$\textunderscore$REQUEST.

\item \emph{REQUEST$\textunderscore$TIMEOUT}: It is the time between the reception of the first COUNT$\textunderscore$REQUEST and the node sending the COUNT$\textunderscore$REPLY
to ``srcOfSmallestHopsAway'' towards the originator.

\end{itemize}

\subsection{COUNT$\textunderscore$REQUEST and COUNT$\textunderscore$REPLY Message}

\begin{figure}[h!]
 \centering
 \includegraphics[width=12cm,height=2cm]{PDU.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Packet Data Unit (PDU)}
\label{fig00}
\end{figure}

\begin{itemize}

 \justifying
    \item Message Type: Can be either 0 or 1. A value of 0 identifies a COUNT$\textunderscore$REQUEST message, while 1 
    is for a COUNT$\textunderscore$REPLY message.
    \item Sequence Number: Is used to match a request with a reply and to distinguish between different requests
    (COUNT$\textunderscore$REQUESTs).
    \item  Timestamp: Is set by the originator when it sends an COUNT$\textunderscore$REQUEST message and is aimed to 
    control out-of-date messages and replay attacks.
    \item hopsAway: The originator and the nodes broadcasts COUNT$\textunderscore$REQUEST messages along with the 
    argument hopsAway which represents the number of hops-away the receiver of the message is from the originator of
    the COUNT$\textunderscore$REQUEST. The originator, which starts the process, must specify a value of hopsAway equal 
    to 1. Each node that rebroadcasts the message will select the smallest hopsAway received and will increment this 
    field by~1.
    \item Hop Limit: It is a way to control how far away COUNT$\textunderscore$REQUEST message are propagated from 
    the originator towards the other nodes. It is also a way to limit the counting range.
    \item Total: Is the total number of nodes based on variable ``Total'' received in COUNT$\textunderscore$REPLY messages 
    (+1 to represent the actual node in the total count). The resulting ``Total'' is sent to node identified as
    ``srcOfSmallestCountAway''. 
\end{itemize}

\subsection{Algorithm}
\justifying
The originator first sends 3 messages of type COUNT$\textunderscore$REQUEST as broadcast with a hopsAway equal to 1 
(separated by INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST). When a node receives the first COUNT$\textunderscore$REQUEST message, 
it will do the following after: 
\begin{itemize}

\justifying
\item REBROADCAST$\textunderscore$TIME: the node rebroadcast the COUNT$\textunderscore$REQUEST with a hopsAway equal to the minimum hopsAway received up to 
now +1. The node also registers the ID of the node (srcOfSmallestHopsAway) that sent the COUNT$\textunderscore$REQUEST with the minimum
hopsAway.
\item  REBROADCAST$\textunderscore$TIME + 1 * INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST: the node rebroadcast
the previous COUNT$\textunderscore$REQUEST (because of possible collision with the first COUNT\\$\textunderscore$REQUEST sent).
\item  REBROADCAST$\textunderscore$TIME + 2 * INTERVAL$\textunderscore$BETWEEN$\textunderscore$REQUEST: the node rebroadcast the previous COUNT$\textunderscore$REQUEST (because of possible
collision with the first and second COUNT$\textunderscore$REQUEST sent).
\item  REQUEST$\textunderscore$TIMEOUT: If the node did receive COUNT$\textunderscore$REPLY messages, then the node computes
the total of nodes based on variable ``Total'' received in COUNT$\textunderscore$REPLY messages (+1 to represent itself in 
the total count) and sends the result to ``srcOfSmallestCountAway''. This is a unicast message.
 
If after REQUEST$\textunderscore$TIMEOUT, the node did not receive COUNT$\textunderscore$REPLY messages, then it generates a 
COUNT$\textunderscore$REPLY with ``Total'' equal to 1 (this 1 represents itself) and sends it to srcOfSmallestHopsAway.
This is a unicast message.
\end{itemize}

\subsection{Example of Propagation}

The scenario for the algorithm is given in the Figure \ref{fig1} where n1, n2,$...$, n10 are nodes. O is the originator. 
The circles around the nodes represent the propagation range.
\begin{figure}[h!]
 \centering
 \includegraphics[height=2.7in]{scenario2.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Scenario for the Algorithm}
\label{fig1}
\end{figure}
\newpage
\textbf{COUNT$\textunderscore$REQUEST Propagation}:
In Figure~\ref{fig2}, we can see how COUNT$\textunderscore$REQUEST are propagated from the originator towards nodes that are 
far away from the originator and how ``hopsAway'' is updated.
\begin{comment}
\begin{figure}[h!]
 \centering
 \includegraphics[height=2.7in]{scenario3.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{COUNT$\textunderscore$REQUEST Propagation}
\end{figure}
\end{comment}


\begin{figure}[h!]
 \centering
 \includegraphics[height=2.5in]{scenario4.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Update the Important Fields in the Propagation of COUNT$\textunderscore$REQUEST Messages}
\label{fig2}
\end{figure}


\textbf{COUNT$\textunderscore$REPLY Propagation}:
In Figure~\ref{fig3}, we can see how COUNT$\textunderscore$REPLY are propagated from nodes that are far away from the originator 
toward the originator and how ``Total'' is updated.

\begin{comment}
\begin{figure}[h!]
 \centering
 \includegraphics[height=2.7in]{scenario5.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{COUNT$\textunderscore$REPLY Propagation}
\end{figure}
\end{comment}

 \begin{figure}[!h]
 \centering
 \includegraphics[height=2.5in]{scenario6.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Update of Total in the Propagation of COUNT$\textunderscore$REPLY Messages}
\label{fig3}
\end{figure}

\newpage
\section{Simulation Using OMNeT++}

This chapter describes the simulation setting used. It lists all the modules used in the dissertation.
\subsection{Simulation Settings}
In the simulation all the broadcasts occur at the same channel frequency. The wireless radio interface used was 802.11g with a maximum range of 
800m. The datarate used is 54Mbps. The following modules are used.
\begin{itemize}
\itemsep0em
\item WirelessHost: It is a compound module. This module is a basically IPv4 host with SCTP, TCP, UDP layers and applications. 
IP forwarding is disabled by default. This is a host with (default) one wireless (802.11) card in infrastructure mode. 
This module is basically a StandardHost with an Ieee80211Nic with mgmtType = Ieee80211MgmtSTA added. It should be used in 
conjunction with AccessPoint, or any other AP model which contains Ieee80211Nic with mgmtType = Ieee80211MgmtAP.
It also contains notificationBoard, routingTable, interfaceTable, mobility modules. A TCP, UDP, SCTP applications runs on it.
These applications are responsible for transferring data from one module to another through different connections. This module 
is named as Origin and Node in the dissertation. Each of the modules has UDP applications which accepts data from Origin/Nodes and can
transfer data to other Nodes/Origin around it.

 \begin{figure}[!h]
 \centering
 \includegraphics[height=2.5in]{mywirelesshost.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Origin and Nodes are extends from wirelesshost module}
\end{figure}

\item UDPOriginApp: It is a simple module. This application broadcasts CountRequest Message within a specific time and also receives CountReply
Message from the nodes. This application counts the total number of nodes around a given specific position. This applications sends a UDP
packet with the following fields like
      \begin{itemize}
      \itemsep0em
       \item msgType
       \item seqNum
       \item timestamp
       \item hopsAway
       \item hopLimit  and 
       \item total
      \end{itemize}      

\item UDPNodeApp: It is also a simple module. This application Receive a broadcast packet and forward the broadcast packet if it is 
received for the first time.
\end{itemize}

\subsection{Experimental Evaluation}

Assume that the scenario to implement the algorithm, there are total three circular area with different radius such as 200, 300 and 400 meters
where the center of origin of these circles are same. Let, there are 10 number of nodes in the first circle, 8 number of nodes in the second circle, 5 number of 
nodes in the third circle. So total 23 number of nodes are exists in the scenario. Each of the nodes are denoted as sta[0], sta[1], sta[2]...sta[22] and the originator is denoted as ``origin''.
In the Figure~\ref{fig4} the scenario is established. Now,the ``origin'' sends broadcast packets that are rebroadcasting by the other nodes only once.
 Keeping the IP address of ``origin'' is 20.0.0.1. The IP address of n0 is 10.0.0.1, the IP address of n1 is 10.0.0.2, and so on.

\begin{figure}[!h]
 \centering
 \includegraphics[height=3.5in]{sc-1.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Origin and Nodes in the simulation scenario (Transmission range=150m)}
\label{fig4}
\end{figure}
We have observed different results after running the simulation with different parameters.
    \begin{itemize}
      \itemsep0em
       \item Now if we keep the Transmission range=150m, we observe that origin response with total 16 nodes are within the scope of ``origin''. 
             different position of nodes can be obtained in the table.dat file.                        
             
             sta[0] 603.59, 394.29\\
	     sta[1] 482.38, 394.72\\
	     sta[2] 679.58, 538.92\\
	     sta[3] 505.81, 503.31\\
	     sta[4] 480.86, 519.67\\
	     sta[5] 620.58, 487.57\\
	     sta[6] 645.44, 410.92\\
	     sta[7] 562.34, 583.55\\
	     sta[8] 461.07, 411.07\\
	     sta[9] 469.07, 508.76\\
	     sta[10] 563.97, 308.31\\
	     sta[11] 535.26, 708.67\\
	     sta[12] 232.85, 500.09\\
	     sta[13] 306.40, 295.48\\
	     sta[14] 758.32, 589.26\\
	     sta[15] 655.27, 326.60\\
	     sta[16] 560.13, 791.67\\
	     sta[17] 637.49, 761.03\\
	     sta[18] 133.00, 392.22\\
	     sta[19] 231.68, 282.93\\
	     sta[20] 857.93, 322.53\\
	     sta[21] 367.57, 873.47\\
	     sta[22] 808.82, 352.11\\
                  
       Now I developed two small programs (fullTable.c and partialTable.c). fullTable.c reads file table.dat and shows all the distance between any two-nodes. 
       And now patialTable.c reads file table.dat and shows the distance to nodes that are within the range of each others. 
       Here, you have to compile it and then run it with the following commands. The argument is to specify the transmission range, in this case let the 
       transmission range of 150.0 meters.\\
       gcc  -o  patialTable  partialTable.c\\
       ./partialTable  150.0\\

       From the last running, we can observe that there are 3 nodes in the transmission range of ``origin'' and these three nodes are sta[1], sta[3], and sta[4], which are
       at 106.74, 6.69, and 27.45 meters from the origin respectively and this information can be seen in the Figure~\ref{fig5} . So, according to the output of partialTable.c, we have the following:\\
       origin    $\Rightarrow $  sta[1], sta[3], sta[4]\\
       sta[1]    $\Rightarrow $  origin, sta[0], sta[3], sta[4]\\
       sta[3]    $\Rightarrow $  origin, sta[1], sta[4]\\
       sta[4]    $\Rightarrow $  origin, sta[1], sta[3]\\
       sta[0]    $\Rightarrow $  sta[1]

This means that when the node that is on the left of $\Rightarrow$  sends a broadcast, it should be received by the list of nodes that are on the right in there is no collision.
That is, when sta[3] sends a broadcast, it is received by ``origin'',sta[1] and sta[4] 

Now we can run the simulation with: ./run | grep CountRequest. We can observe that every broadcast generated by ``origin'' has a ``Sequence Number''. Also,
it shows information about ``hopsAway''.

There is a parameter called TIME$\textunderscore$FOR$\textunderscore$REBROADCAST. This parameters is to avoid collision. Here configured for rebroadcast
once, so if 2 or more nodes try to rebroadcast at the same time, it will have a collision, and since as the rebroadcast once, the propagation of 
the broadcast will be very limited. To analyze with this parameter, here the value is 0.0 seconds and after run the simulation. 
We observe that the only broadcasts that are sent without collisions are the ones of ``origin''. sta[1], sta[3] and sta[4] do rebroadcast once, 
but since they do it at the same time, a collision occurs, and the rebroadcast of sta[1], sta[3] and sta[4] are
seen by the other nodes as noise. Here we have another parameter called NUM$\textunderscore$REBROADCASTS. Its value should be 2 to get a total of 3 broadcasts
(1 broadcast + 2 rebroadcasts).

Also, as the proposal was saying, now we have a unique packet called CountMsg (defined in CountMsg.msg). So, according to 
msgType, it will be a CountRequest or a CountReply packet.

We keep the one important paramater timeOfCountRequest in .ini file as \\
$\ast$.origin.udpApp[0].timeOfCountRequest = "20.0 25.5 67.5 100.8"

This means that the ``origin'' is starting a CountRequest process at different times (20.0, 25.5, 67.5, and 100.8 seconds). 
So, this means that ``origin'' is starting 4 independent CountRequest and these CountRequest have different seqNum (0, 1, 2, and 3).
       
             Here we also analyze that, sta[0], sta[1], sta[3], sta[4], sta[5], sta[7], sta[8], sta[9]: are 1 hop away from ``origin''. sta[2], sta[6], sta[10], sta[11], sta[15]: 
             are 2 hops away from ``origin''. sta[14], sta[16], sta[17]: are 3 hops away from ``origin'' and the distance from origin to nodes in terms of hopsAway
             can be seen in the Figure~\ref{fig5} So here it is observed that as the transmission range is not so strong we are getting maximum 16 number of nodes counted by the 
             origin.
\FloatBarrier                                
\begin{sidewaysfigure}[ht]
 \centering
 \includegraphics[height=2.7in]{partialtable.png}
 %\includegraphics[height=0.7in]{fig3.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Node-to-node distances(Transmission Range=150)}
\label{fig5}
\end{sidewaysfigure}
\FloatBarrier             
             
    
       \item Now if we want to count all the nodes in the scenario then the transmission range must be the diameter of the outer circle suppose
             there may be two nodes in extreme sides of the circle (separate 800 meters). So by keeping the transmission range=800m, we observed that origin 
	      counted total 23 number of nodes which are exactly match with the scenario.
	      
	      If we run the simulation with the following command
	      ./run\textbar egrep ``counted\textbar has coordinates''
	      we observed the following output.
			    
	      \begin{figure}[h]
	      \centering
	      \includegraphics[height=3.7in]{sc-2.png}
	      \caption{Output of ./run\textbar egrep ``counted\textbar has coordinates''}
	      \end{figure}        
	     \FloatBarrier
	      \item We have observed different numbers of nodes counted by origin when the speed of the nodes varies from 1mps to 100 mps with the different seed values
		    like seed-0-mt=12, seed-1-mt=9, seed-2-mt=7. the following graph (Figure~\ref{fig6}) has been found based on the output. From the graph it can be observed that
		    When the speed of the nodes are increased, the origin counted the less number of nodes. In this simulation we have used Random-way-point-mobility
		    (RandomWPMobility). We are getting the best result when the speed is 1mps.		       
	             
	      
	      \item We have observed another scenario when the seed-0-mt=\textbraceleft1..12\textbraceright, the best result we got at 1 mps. The following graph 
	      (Figure~\ref{fig7}) has been found.
	      \FloatBarrier 
	      \begin{figure}[h]
	      \centering
	      \includegraphics[height=3.7in]{file.png}
	      \caption{Total number of car response by Origin Vs Speed (mps) with different seed values}
	      \label{fig6}
	      \end{figure} 
	      
	      \begin{figure}[h]
	      \centering
	      \includegraphics[height=3.7in]{file1.png}
	      \caption{Total number of car response by Origin Vs Seed-0-mt=\textbraceleft1..12\textbraceright with different speed}
	      \label{fig7}
	      \end{figure}
	      \FloatBarrier 
	      \item It has been observed that by keeping the speed=1mps and seed-0-mt=12, if different numbers of nodes are varies in the 
	      respective three circular areas. There may be different results and maximum time the total number of nodes counted by the origin is 
	      same as the original scenario. Based on the simulated data the following graph (Figure~\ref{fig8}) has been found. It has been observed that
	      when the nodes are 10+10+15 i.e. the number of nodes in the first circle, second circle and third circle, origin counted 34 instead of 
	      35 and if the number of nodes are 10+15+10, 15+10+10 origin counted exactly 35. Similarly we have observed the following cases also
	      15+15+20, 15+20+15, 20+15+15, origin counted exactly 50 nodes and in the other case, if the number of nodes are 20+20+20, origin counted 58,
	      10+10+40 origin counted 57, 10+20+30 origin counted 58, 40+10+10 origin counted	60.
	      \begin{figure}[!ht]
	      \centering
	      \includegraphics[height=3.7in]{file2.png}
	      \caption{Total number of car response by Origin Vs different number of cars in the three circular areas at speed=1mps}
	      \label{fig8}
	      \end{figure}
	      
	      
      \end{itemize}      




