
\chapter{The Discrete Event Simulation System OMNeT++}
\justifying
Simulation was done using OMNeT++ and INET Framework for this dissertation. This chapter
presents the features of the OMNeT++ simulator, INET framework and applications used for simulation.

\section{Introduction}
\justifying
Objective Modular Network Testbed in C++ (OMNeT++) is an object-oriented
modular discrete event network simulator which can be used for traffic modeling
of telecommunication networks, on-chip networks, protocols, queuing networks, multi-processors and
other distributed hardware systems as well as validating hardware architectures or
evaluating performance aspects of complex software systems.

An OMNeT++ module consists of hierarchically nested modules which communicate by passing messages to
one another. The nesting of submodules is not limited, and thus model structure can reflect the logical structure of the actual system. The
lowest level of the module hierarchy contains the algorithms implemented in C++ in an event-driven or process-style way.
Model structure is described in OMNeT++'s NED language. NED means NEtwork Description which is a simple yet powerful topology description language
employed by OMNeT++. NED facilitates the network description process by allowing
different component descriptions for simple modules, compound modules and channels.
These component descriptions can be reused in another network description. A NED
description can contain the following components:
\begin{itemize}
\itemsep0em
\item Import directives
\item Channel definitions
\item Simple module definitions
\item Compound module definitions
\item Network definitions
\end{itemize}

Gates are the input and output interfaces of modules through which
messages are sent in or out. Each connection (also called link) is created within a single level of the module 
hierarchy: within a compound module, one can connect the corresponding gates of two submodules, or a gate of one submodule and a gate of
the compound module. Connections can be assigned three parameters propagation delay, bit error rate and data 
rate which facilitate the modeling of communication networks, but can be useful in other models too.

OMNeT++ is free for academic and non-profit use, and it is a widely used platform in the global scientific community. 
Commercial users must obtain a license from omnest.com.

Next we will now look into the basic modeling concepts of discrete-event simulation and
introduce the rudiments of OMNeT++.

\section{Simulation Modeling Concepts}
\subsection{Discrete Event Simulation}
A discrete-event simulation is one in which the state of a model changes only at discrete,
but possibly random, instances in time.

An event is an occurrence that changes the state of the model. In a DES events take zero
time to happen and it is assumed that no state changes in the model takes place between
events. The time when an event occurs is called an event timestamp and the time within the
model is referred to as simulation time. Real time (or wall-clock time) refers to how long
the simulation is actually running.

The opposite of discrete event simulation models are continuous simulation models where
states change all the time. Numerous systems like manufacturing, transportation, health
care, communication, defenses, information processing, and queuing systems can be
modeled using discrete event simulation.

An entity can be seen as a traffic unit that moves from one point to another in the model.
An entity can be in one of five states:

\begin{enumerate}
\itemsep0em
 \item Active state: The active state is the state in which the currently moving entity is.
 \item Ready state: The ready state is a state for entities waiting to enter the active state
(i.e. there is more than one entity ready to move but they have to do it one at a
time).

\item Time-delayed state: The time-delayed state is a state in which an entity is waiting
for a known future simulated time to be reached before entering the Ready state.

\item Condition-delayed state: The condition-delayed state is a state in which an entity is
waiting for a certain condition to be satisfied before entering the Ready state.

\item Dormant state: The dormant state represents a sort of hold or sleep state. When an
entity is in the Dormant state, changes in the model conditions cannot trigger a state
transfer. Modeler logic is required to transfer an entity from the Dormant to the
Ready state.
\end{enumerate}

A DES provides a set of lists for each of the five states to organize and track entities. We
will quickly look at the Future Events List (FEL) used for entities in the Time-delayed
state.

\subsection{The event loop}
The Future Events List is also known as the Future Event Set (FES) and contains the set of
future events, i.e. entities with a time-based delay are inserted into the FES. Figure~\ref{fig9}
illustrates the basic steps a DES would typically take to implement the event loop. To
ensure causality (that no event effect earlier events), all events are processed in a strict
timestamp order.
\begin{figure}[h!]
 \centering
 \includegraphics[height=5.5in]{flowchart.png}
 %% fig1.png: 1024x768 pixel, 96dpi, 27.09x20.32 cm, bb=
\caption{Flowchart illustrating typical event loop}
\label{fig9}
\end{figure}

\pagebreak


\section{INET Framework}
The INET Framework is an open-source communication networks simulation package for the OMNeT++ simulation environment.
The INET Framework contains models for several wired and wireless networking protocols, including UDP, TCP, SCTP, IP, IPv6, 
Ethernet, PPP, 802.11, MPLS, OSPF, and many others.
INET-2.1.0 is the latest stable version of the INET Framework. This version is now recommended for further INET-based development. 
It requires OMNeT++ 4.2 or 4.3. Some common INET modules are as follows:
\begin{itemize}
\itemsep0em
\item ChannelControl: This module has exactly one instance in every network model that contains mobile or wireless nodes. 
      This module gets informed about the location and movement of nodes, and determines which nodes are within 
      communication or interference distance. This info is then used by the radio interfaces of nodes at transmissions.
      Must be named as ``channelControl'' inside the network.
\item FlatNetworkConfigurator: This module Configures IPv4 addresses and routing tables for a ``flat'' network, ``flat'' meaning that 
      all hosts and routers will have the same network address and will only differ in the host part.
      This module doesn't connect to any other modules (it has no gates), and should have only one instance in the whole model. 
      The module will only run once, at the beginning of the simulation. When it runs, it will:
      \begin{enumerate}
      \itemsep0em
      \item assign IPv4 addresses to hosts and routers. All hosts and routers will be in the same network (same network address). 
             For simplicity, it will assign the same address to all interfaces of a router;
      \item then it'll discover the topology of the network (using OMNeT++'s cTopology class), and calculate shortest paths;
      \item finally, it will add routes which correspond to the shortest paths to the routing tables (see RoutingTable::addRoutingEntry()).
      \end{enumerate}
      The configurator picks all modules which have a @node property and their connections, and builds a graph from it. 
      Then it runs Dijkstra's shortest path algorithm on it, and configures all modules which are IPv4 nodes. 
\item NotificationBoard: This module modules can now notify each other about ``events'' such as routing table changes, 
      interface status changes (up/down), interface configuration changes, wireless handovers, changes in the state of the wireless 
      channel, mobile node position changes, etc. It has exactly one instance within a host or router model, and acts as a intermediary
      between module where state changes can occur and modules which are interested in learning about those changes. 
      It *must* be named as ``notificationBoard'' to work correctly. Modules can ``subscribe'' to categories of changes 
      (e.g. ``routing table changed'' or ``radio channel became empty''). When such a change occurs, the corresponding module 
      will let NotifcationBoard know, and it will disseminate this information to all interested modules.      
\item InterfaceTable: It Keeps the table of network interfaces. Interfaces are dynamically registered by the corresponding L2 modules,
      e.g. PPPInterface. In addition to registered interfaces, a loopback interface will also be created. This table only contains 
      protocol-independent properties of interfaces -- IPv4 or IPv6 specific per-interface data (addresses etc) are kept in RoutingTable 
      and RoutingTable6. Must be named as ``interfaceTable''. This module has no gates; all functionality can be accessed via member 
      functions of the C++ module class.
\item RoutingTable: This module contains the IP (v4) routing table, and heavily relies on InterfaceTable for its operation. 
      It implements functions for querying, adding, deleting routes, and finding the best matching route for a given destination IP address.
\item MobileHost: The mobile has follows ISO/OSI architecture. It is composed of Network Layer, Transport Layer and Application Layer 
      sub-modules. In the INET Framework, when an upper-layer protocol wants to send a data packet over a lower-layer protocol, 
      the upper-layer module just sends the message object representing the packet to the lower-layer module, which will in turn encapsulate it
      and send it. The reverse process takes place when a lower layer protocol receives a packet and sends it up after decapsulation.
\item TCP: This module is compatible with both IPv4 and IPv6. A TCP segment is represented by the class TCPSegment. For communication between 
      client applications and TCP, the TcpCommandCode and TcpStatusInd enums are used as message kinds, and TCPCommand and its subclasses are 
      used as control info. TCP sends notifications to the application whenever there's a significant change in the state of the connection:
      established, remote TCP closed, closed, timed out, connection refused, connection reset, etc. These notifications are also cMessages 
      with message kind TCP$\textunderscore$I$\textunderscore$xxx (TCP$\textunderscore$I$\textunderscore$ESTABLISHED, etc.) and 
      TCPCommand as control info. One TCP module can serve several application modules, and several connections per application. 
      The kth application connects to TCP's appIn[k] and appOut[k] ports. When talking to applications, a connection is identified by the 
      (application port index, connId) pair, where connId is assigned by the application in the OPEN call. The TCPSocket C++ class is provided to 
      simplify managing TCP connections from applications. TCPSocket handles the job of assembling and sending command messages (OPEN, CLOSE, etc)
      to TCP, and it also simplifies the task of dealing with packets and notification messages coming from TCP.The TCP model relies on sending 
      and receiving IPv4ControlInfo objects attached to TCP segment objects as control info (see cMessage::setControlInfo()).
\item UDP: This module is compatible with both IPv4 and IPv6. The UDP protocol header is represented by the class UDPPacket. The module can 
    (should) be connected to several applications. For sending an UDP packet, the application should attach an UDPControlInfo object to 
    the payload, and send it to UDP. UDP will also attach an UDPControlInfo object to any payload message in sends up to the application.For 
    receiving UDP packets, the connected applications should first ``bind'' to the given UDP port. This can be done by sending an arbitrary 
    message with message kind UDP$\textunderscore$C$\textunderscore$BIND and an UDPControlInfo attached with srcPort filled in.
    When UDP receives an ICMP error (ICMPMessage or ICMPv6Message) that refers to an UDP socket, it reports the error to the corresponding 
    application by sending a message with kind UDP$\textunderscore$I$\textunderscore$ERROR. The UDP model relies on sending and receiving 
    IPv4ControlInfo/IPv6ControlInfo objects attached to UDPPacket objects as control info.
\item Radio: It implements the physical layer for 802.11 models. It consists of several sub modules oriented on the ISO/OSI stack 
      like the MAC layer, Decider layer and SNREval. While SNREval module is responsible for recording the signal and noise power at
  different points in time (at each transmitted signal), the decider module uses that information along with the applied modulation 
  scheme to calculate the bit error rate or to mark erroneus bits if needed. These modules provided by INET Framework can be freely 
  combined to form hosts and other network devices with the NED language (no C++ code and no recompilation required).    
\item Network: This module is a compound and represents the Network layer of an IP node. It has Interfaces to transport layer: 
      TCP, UDP, echo/ping, RSVP modules.    
\end{itemize}
